<Gratin type="pipeline">
 <int val="0" name="majorVersion"/>
 <int val="3" name="minorVersion"/>
 <IOData name="mainWindow">
  <IOData name="graphWidget">
   <IOData name="graph">
    <uint val="1" name="nbNodes"/>
    <string val="imgGenericId" name="nodeStringId-0"/>
    <uint val="1" name="nodeVersion-0"/>
    <string val="init" name="nodeName-0"/>
    <string val="Generic/" name="nodePath-0"/>
    <string val="Generic node for image processing" name="nodeDesc-0"/>
    <string val="This node was designed to create custom shaders&#xa;The settings widget allows to modify input, output parameters&#xa;as well as the output image sizes.&#xa;&#xa;WARNING1: you will be able to modify the number of inputs/outputs&#xa;only if the node is entirely disconnected.&#xa;WARNING2: input/output names will not be modified if a custom node is created&#xa;from this node because these names should be edited directly in the setting widget&#xa;WARNING3: modifying the settings of a node will remove all previously&#xa;defined keyframes&#xa;&#xa;* Special data allows to modify the output image (using a multiple of&#xa;the input size, plus an offset vector&#xa;Check use mouse/keyboard if you want to interact with the mouse&#xa;&#xa;* Input data allows to add/remove/displace input data (only if disconnected)&#xa;&#xa;* Output data allows to add/remove/displace output data (only if disconnected)&#xa;&#xa;* Param data allows to add/remove parameters that will automatically be &#xa;included in your shader.&#xa;For each of them you may choose a proper name, type, and min/max/default values.&#xa;Check keyframes if you want your parameter to be accessible&#xa; through the animation widget&#xa;&#xa;In the node interface itself:&#xa;Source tab contains the head and body of your GLSL source (only the body is editable)&#xa;Params tab contains the defined widgets according to your setting choices&#xa;Log tab contains compilation errors&#xa;&#xa;Once your settings and source completed, click on apply to see the result&#xa;" name="nodeHelp-0"/>
    <uint val="0" name="nodeId-0"/>
    <uint val="0" name="nodeGraphId-0"/>
    <vector2f name="nodePos-0">
     <float val="1804.62" name="0"/>
     <float val="-3399.46" name="1"/>
    </vector2f>
    <int val="0" name="nodeInputNameSize-0"/>
    <int val="1" name="nodeOutputNameSize-0"/>
    <string val="outBuffer0" name="nodeOutputName-0-0"/>
    <bool val="1" name="nodeHasWidget-0"/>
    <IOData name="node-0">
     <string val="420" name="genericGlslVersion"/>
     <string val="init" name="genericNodeName"/>
     <bool val="0" name="genericUseVertex"/>
     <bool val="0" name="genericUseTesselation"/>
     <bool val="0" name="genericUseGeometry"/>
     <bool val="1" name="genericUseFragment"/>
     <int val="9729" name="genericOutFilter"/>
     <int val="33071" name="genericOutWrap"/>
     <bool val="0" name="genericUseDepthTest"/>
     <bool val="0" name="genericUseBlending"/>
     <uint val="513" name="genericDepthFunc"/>
     <uint val="1" name="genericBlendSrc"/>
     <uint val="0" name="genericBlendDst"/>
     <vector4f name="genericBackground">
      <float val="0" name="0"/>
      <float val="0" name="1"/>
      <float val="0" name="2"/>
      <float val="0" name="3"/>
     </vector4f>
     <string val="#version 420&#xa;&#xa;layout(location = 0) in vec2 vertex;&#xa;layout(location = 1) in vec2 coord;&#xa;uniform vec2 mouse;&#xa;" name="genericVertHead"/>
     <string val="out vec2 texcoord;&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = vec4(vertex,0,1);&#xa;&#x9;texcoord    = coord;&#xa;}&#xa;" name="genericVertBody"/>
     <string val="#version 420&#xa;&#xa;layout(location = 0) out vec4 outBuffer0;&#xa;uniform vec2 mouse;&#xa;" name="genericFragHead"/>
     <string val="in vec2 texcoord;&#xa;in vec4 gl_FragCoord;&#xa;#define NUM_PLANS 1&#xa;#define NUM_SPHERES 2&#xa;#define NUM_COULEURS 7&#xa;#define NB_ITER_MAX 100&#xa;precision highp float;&#xa;&#xa;//Camera&#xa;//defini par une position et 3 vecteurs (up,view,right)&#xa;struct Camera{&#xa;&#x9;vec3 e;//position de la camera&#xa;&#x9;vec3 u; // right&#xa;&#x9;vec3 v; // vecteur up&#xa;&#x9;vec3 w; //vecteur view direction vers la scene&#xa;};&#xa;&#xa;//Plan&#xa;struct Plane{&#xa;&#x9;vec3 n;//normal&#xa;&#x9;float d;//offset&#xa;};&#xa;&#xa;//Plan implicite&#xa;float sdPlane( vec3 p, vec4 n )&#xa;{&#xa;  // n must be normalized&#xa;  return dot(p,n.xyz) +n.w;&#xa;}&#xa;&#xa;&#xa;//Rayon&#xa;struct Ray{&#xa;&#x9;vec3 ro; //origin&#xa;&#x9;vec3 rd; //direction&#xa;};&#xa;&#xa;//Sphere&#xa;struct Sphere{&#xa;&#x9;vec3 o; //origin&#xa;     float r;//rayon&#xa;};&#xa;&#xa;float sdSphere( vec3 p, vec3 o, float s )&#xa;{&#xa;&#x9;//return length(p)-s;&#xa;&#x9;float po = distance(p,o);&#xa;&#x9;return length(o - p) - s;&#xa;&#xa;}&#xa;&#xa;struct Paquet{&#xa;&#x9;vec3 n;&#xa;&#x9;float dist;&#xa;&#x9;int coul;&#xa;};&#xa;&#xa;//attributs&#xa;Camera cam;&#xa;Plane murs[ NUM_PLANS ];&#xa;Sphere balles[NUM_SPHERES];&#xa;vec4 couleurs[NUM_COULEURS];&#xa;vec3 lumiere;&#xa;&#xa;&#xa;//initialisation de la caméra&#xa;void initCam(){&#xa;&#xa;&#x9;//souris normalisée&#xa;&#x9;vec2 m = mouse/512.0;&#xa;&#xa;&#x9;//position de la caméra&#xa;&#x9;//cam.e = vec3(1,1,1);&#xa;&#xa;&#x9;//position de la caméra contrôlée par la souris&#xa;&#x9;cam.e = vec3(m.x,m.y,2);&#xa;&#xa;&#x9;//direction vue (là où on regarde) , ici on regarde selon l'axe z&#xa;&#x9;cam.w = vec3(0,0,-1);&#xa;&#xa;&#x9;//direction up &#xa;&#x9;cam.v = vec3(0,1,0);&#xa;&#xa;&#x9;//on recalcule pour que tout soit orthogonal&#xa;&#x9;cam.u= cross(cam.w,cam.v);&#xa;&#x9;cam.v = cross(cam.u,cam.w);&#xa;}&#xa;&#xa;void initLight(){&#xa;&#x9;lumiere = normalize(vec3(1,1,0));&#xa;//&#x9;lumiere = normalize(vec3(10,1,0));&#xa;&#xa;}&#xa;&#xa;//initialisation des plans, ici 5 &quot;murs&quot;&#xa;void initPlans(){&#xa;&#x9;//Salle : Fond de la salle, Mur gauche , Sol de la salle, Mur droit, Plafond &#xa;&#x9;//murs = Plane[]( Plane(vec3(0,0,1),-0.5) , Plane(vec3(1,0,0),2) , Plane(vec3(0,1,0),-0.5) , Plane(vec3(-1,0,0),0.5) , Plane(vec3(0,1,0),0.5) );&#xa;&#x9;//plan bas &#xa;&#x9;murs = Plane[](Plane(normalize(vec3(0,1,0)),0.5) );&#xa;&#xa;&#x9;//3 plans principaux Oxy , Oyz et Ozx &#xa;&#x9;//murs = Plane[](Plane(normalize(vec3(0,0,1)),0), Plane(normalize(vec3(1,0,0)),0), Plane(normalize(vec3(0,1,0)),0) ); &#xa;&#xa;}&#xa;&#xa;//initialisation des spheres&#xa;void initSpheres(){&#xa;&#x9;//On place la sphère&#xa;&#x9;balles = Sphere[](Sphere(vec3(0,1,0),0.4),Sphere(vec3(0,1.8,0),0.3) ) ;&#xa;}&#xa;&#xa;void initCouleur(){&#xa;&#x9;// COULEURS DIFFERENTES&#xa;&#x9;//[BLEU ; MAGENTA ; ROUGE ; JAUNE ; VERT ;CYAN]&#xa;&#x9;couleurs = vec4[](vec4(0,0,1,1), vec4(1,0,1,1), vec4(1,0,0,1), vec4(1,1,0,1), vec4(0,1,0,1),vec4(0,1,1,1),vec4(0,0,0,1));&#xa;}&#xa;&#xa;&#xa;//Shading simple&#xa;//Prend un paquet en entrée : un paquet est une structure composée d'un vec3 n qui est une norme&#xa;//d'un float dist qui est la distance entre le point et la lumiere&#xa;//d'un entier coul qui est l'indice de la couleur à afficher&#xa;//cette fonction est appelée dans la fonction RayMarching&#xa;//vec4 directIllumination(Paquet p){&#xa;&#xa;&#x9;//On prend la position du pixel entre [-1 ; 1]&#xa;&#x9;//vec2 pos =( gl_FragCoord.xy - (512.0/2) ) / (512.0/2) ;&#xa;&#xa;  //  &#x9;return dot(p.n,lumiere)*p.dist*vec4(couleurs[p.coul].xyz,1);&#xa;//}&#xa;&#xa;&#xa;//Ray Marching&#xa;vec4 rayMarchingSimple(){&#xa;&#xa;&#x9;//On prend la position du pixel entre [-1 ; 1]&#xa;&#x9;vec2 pos =( gl_FragCoord.xy - (512.0/2) ) / (512.0/2) ;&#xa;&#x9;&#xa;&#x9;//On affiche la source de lumiere&#xa;&#x9;if(pos.x >= lumiere.x-0.1 &amp;&amp; pos.x &lt;= lumiere.x+0.1 &amp;&amp; pos.y >= lumiere.y-0.1 &amp;&amp; pos.y &lt;= lumiere.y+0.1){&#xa;&#x9;&#x9;return couleurs[5];&#xa;&#x9;}&#xa;&#xa;&#x9;//generer un rayon avec la camera&#xa;&#x9;float D  = 1.0/(tan(3.14/4.0)); //radian&#xa;&#x9;Ray ray = Ray( cam.e , normalize(vec3(pos.x*cam.u+pos.y*cam.v+D*cam.w)) ) ;&#xa;&#x9;Plane plan ;&#xa;&#x9;Sphere ball ;&#xa;&#x9;vec3 p;&#xa;&#xa;&#x9;float t =0;&#xa;&#xa;&#x9;vec4 n;&#xa;&#xa;&#x9;float pas =0.1;&#xa;&#xa;&#x9;float dist[ NUM_PLANS+NUM_SPHERES ];&#xa;&#xa;&#x9;for( int i=0;i&lt;NB_ITER_MAX;i++){&#xa;&#xa;&#x9;&#x9;p = ray.ro + ray.rd*t;&#x9;&#x9;&#xa;&#xa;&#xa;&#x9;&#x9;for(int j=0;j&lt;NUM_PLANS+NUM_SPHERES;j++){&#xa;&#x9;&#x9;&#x9;if(j &lt; NUM_PLANS){&#xa;&#x9;&#x9;&#x9;&#x9;n = vec4(murs[j].n,murs[j].d);&#xa;&#x9;&#x9;&#x9;&#x9;dist[j] = sdPlane(p,n);&#xa;&#x9;&#x9;&#x9;&#x9;if(dist[j] &lt;=0){&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;return couleurs[j];&#xa;&#xa;&#x9;&#x9;&#x9;&#x9;}&#xa;&#x9;&#x9;&#x9;}else{&#xa;&#x9;&#x9;&#x9;&#x9;dist[j] = sdSphere(p,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;if(dist[j] &lt;=0){&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;return couleurs[j];&#xa;&#x9;&#x9;&#x9;&#x9;}&#xa;&#x9;&#x9;&#x9;}&#xa;&#xa;&#x9;&#x9;}&#xa;&#x9;&#x9;t += pas;&#xa;&#x9;}&#xa;return couleurs[6];&#xa;}&#xa;&#xa;&#xa;&#xa;vec4 rayMarchingNormales(){&#xa;&#xa;&#x9;//On prend la position du pixel entre [-1 ; 1]&#xa;&#x9;vec2 pos =( gl_FragCoord.xy - (512.0/2) ) / (512.0/2) ;&#xa;&#x9;&#xa;&#x9;//generer un rayon avec la camera&#xa;&#x9;float D  = 1.0/(tan(3.14/4.0)); //radian&#xa;&#x9;Ray ray = Ray( cam.e , normalize(vec3(pos.x*cam.u+pos.y*cam.v+D*cam.w)) ) ;&#xa;&#x9;Plane plan ;&#xa;&#x9;Sphere ball ;&#xa;&#x9;vec3 p;&#xa;&#xa;&#x9;float t =0;&#xa;&#x9;vec4 n ;&#xa;&#xa;&#x9;float pas =0.1;&#xa;&#xa;&#x9;float dist[ NUM_PLANS+NUM_SPHERES ];&#xa;&#xa;&#x9;for( int i=0;i&lt;NB_ITER_MAX;i++){&#xa;&#xa;&#x9;&#x9;p = ray.ro + ray.rd*t;&#x9;&#x9;&#xa;&#xa;&#xa;&#x9;&#x9;for(int j=0;j&lt;NUM_PLANS+NUM_SPHERES;j++){&#xa;&#x9;&#x9;&#x9;if(j &lt; NUM_PLANS){&#xa;&#x9;&#x9;&#x9;&#x9;n = vec4(murs[j].n,murs[j].d);&#xa;&#x9;&#x9;&#x9;&#x9;dist[j] = sdPlane(p,n);&#xa;&#x9;&#x9;&#x9;&#x9;if(dist[j] &lt;=0){&#xa;&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;//normales:&#x9;&#x9;&#x9;&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;return vec4(n.xyz,t);&#xa;&#xa;&#xa;&#x9;&#x9;&#x9;&#x9;}&#xa;&#x9;&#x9;&#x9;}else{&#xa;&#x9;&#x9;&#x9;&#x9;dist[j] = sdSphere(p,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;if(dist[j] &lt;=0){&#xa;&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;//normales&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;//calculs des points avant et  apres selon x, y et z pour calculer le gradient -> normale&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 pprecx =  vec3(p.x-pas,p.y,p.z);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 pprecy =  vec3(p.x,p.y-pas,p.z);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 pprecz =  vec3(p.x,p.y,p.z-pas);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 psuivx =  vec3(p.x+pas,p.y,p.z);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 psuivy =  vec3(p.x,p.y+pas,p.z);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 psuivz =  vec3(p.x,p.y,p.z+pas);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distprecx =  sdSphere(pprecx,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distprecy =  sdSphere(pprecy,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distprecz =  sdSphere(pprecz,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distsuivx = sdSphere(psuivx,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distsuivy = sdSphere(psuivy,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distsuivz = sdSphere(psuivz,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;//On normalise les coordonnees de la normale&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 norm =  normalize(vec3(distsuivx-distprecx,distsuivy-distprecy,distsuivz-distprecz));&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;return vec4(  norm,1);&#xa;&#x9;&#x9;&#x9;&#x9;}&#xa;&#x9;&#x9;&#x9;}&#xa;&#xa;&#x9;&#x9;}&#xa;&#x9;&#x9;t += pas;&#xa;&#x9;}&#xa;&#x9;return couleurs[6];&#xa;}&#xa;&#xa;&#xa;vec4 rayMarchingProfondeur(){&#xa;&#xa;&#x9;//On prend la position du pixel entre [-1 ; 1]&#xa;&#x9;vec2 pos =( gl_FragCoord.xy - (512.0/2) ) / (512.0/2) ;&#xa;&#xa;&#x9;//generer un rayon avec la camera&#xa;&#x9;float D  = 1.0/(tan(3.14/4.0)); //radian&#xa;&#x9;Ray ray = Ray( cam.e , normalize(vec3(pos.x*cam.u+pos.y*cam.v+D*cam.w)) ) ;&#xa;&#x9;Plane plan ;&#xa;&#x9;Sphere ball ;&#xa;&#x9;vec3 p;&#xa;&#xa;&#x9;float t =0;&#xa;&#x9;vec4 n;&#xa;&#xa;&#x9;float pas =0.1;&#xa;&#xa;&#x9;float dist[ NUM_PLANS+NUM_SPHERES ];&#xa;&#xa;&#x9;for( int i=0;i&lt;NB_ITER_MAX;i++){&#xa;&#xa;&#x9;&#x9;p = ray.ro + ray.rd*t;&#x9;&#x9;&#xa;&#xa;&#xa;&#x9;&#x9;for(int j=0;j&lt;NUM_PLANS+NUM_SPHERES;j++){&#xa;&#x9;&#x9;&#x9;if(j &lt; NUM_PLANS){&#xa;&#x9;&#x9;&#x9;&#x9;n = vec4(murs[j].n,murs[j].d);&#xa;&#x9;&#x9;&#x9;&#x9;dist[j] = sdPlane(p,n);&#xa;&#x9;&#x9;&#x9;&#x9;if(dist[j] &lt;=0){&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;//profondeur :&#x9;&#x9;&#x9;&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;return vec4( t/(NB_ITER_MAX*pas) , t/(NB_ITER_MAX*pas)  , t/(NB_ITER_MAX*pas) ,1);&#xa;&#x9;&#x9;&#x9;&#x9;}&#xa;&#x9;&#x9;&#x9;}else{&#xa;&#x9;&#x9;&#x9;&#x9;dist[j] = sdSphere(p,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;if(dist[j] &lt;=0){&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;//profondeur&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;return vec4( t/(NB_ITER_MAX*pas) , t/(NB_ITER_MAX*pas)  , t/(NB_ITER_MAX*pas) ,1);&#xa;&#x9;&#x9;&#x9;&#x9;}&#xa;&#x9;&#x9;&#x9;}&#xa;&#xa;&#x9;&#x9;}&#xa;&#x9;&#x9;t += pas;&#xa;&#x9;}&#xa;&#x9;return couleurs[6];&#xa;}&#xa;&#xa;&#xa;vec4 directIllumination(vec2 pos){&#xa;&#xa;&#x9;//rayon est le &quot;rayon&quot; de la representation de la source lumineuse &#xa;&#x9;float rayon = 0.1;&#xa;&#x9;&#xa;&#x9;if(  (pow(pos.x-lumiere.x,2) + pow(pos.y-lumiere.y,2) &lt;= pow(rayon,2)) ){&#xa;&#x9;   // return couleurs[3]*vec4( rayon/distance(pos,lumiere.xy),rayon/distance(pos,lumiere.xy),rayon/distance(pos,lumiere.xy),1);&#xa;&#x9;&#x9;return couleurs[3];&#xa;&#x9;}&#xa;&#x9;&#xa;   &#x9;&#x9;// return dot(vec3(1,1,1),lumiere)*1*vec4(couleurs[6].xyz,1);&#xa;&#x9;&#x9;return couleurs[6];&#xa;}&#xa;&#xa;vec4 shadingSimple(){&#xa;&#xa;&#x9;//On prend la position du pixel entre [-1 ; 1]&#xa;&#x9;vec2 pos =( gl_FragCoord.xy - (512.0/2) ) / (512.0/2) ;&#xa;&#xa;&#xa;&#x9;//generer un rayon avec la camera&#xa;&#x9;float D  = 1.0/(tan(3.14/4.0)); //radian&#xa;&#x9;Ray ray = Ray( cam.e , normalize(vec3(pos.x*cam.u+pos.y*cam.v+D*cam.w)) ) ;&#xa;&#x9;Plane plan ;&#xa;&#x9;Sphere ball ;&#xa;&#x9;vec3 p;&#xa;&#xa;&#x9;float t =0;&#xa;&#x9;vec4 n;&#xa;&#xa;&#x9;float pas =0.1;&#xa;&#xa;&#x9;float dist[ NUM_PLANS+NUM_SPHERES ];&#xa;&#xa;&#x9;for( int i=0;i&lt;NB_ITER_MAX;i++){&#xa;&#xa;&#x9;&#x9;p = ray.ro + ray.rd*t;&#x9;&#x9;&#xa;&#xa;&#xa;&#x9;&#x9;for(int j=0;j&lt;NUM_PLANS+NUM_SPHERES;j++){&#xa;&#x9;&#x9;&#x9;if(j &lt; NUM_PLANS){&#xa;&#x9;&#x9;&#x9;&#x9;n = vec4(murs[j].n,murs[j].d);&#xa;&#x9;&#x9;&#x9;&#x9;dist[j] = sdPlane(p,n);&#xa;&#x9;&#x9;&#x9;&#x9;if(dist[j] &lt;=0){&#xa;    &#x9;&#x9;&#x9;&#x9;&#x9;return dot(n.xyz,lumiere)*distance(p.xyz,lumiere)*vec4(couleurs[j].xyz,1);&#xa;&#xa;&#x9;&#x9;&#x9;&#x9;}&#xa;&#x9;&#x9;&#x9;}else{&#xa;&#x9;&#x9;&#x9;&#x9;dist[j] = sdSphere(p,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;if(dist[j] &lt;=0){&#xa;&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;//normales&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;//calculs des points avant et  apres selon x, y et z pour calculer le gradient -> normale&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 pprecx =  vec3(p.x-pas,p.y,p.z);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 pprecy =  vec3(p.x,p.y-pas,p.z);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 pprecz =  vec3(p.x,p.y,p.z-pas);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 psuivx =  vec3(p.x+pas,p.y,p.z);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 psuivy =  vec3(p.x,p.y+pas,p.z);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 psuivz =  vec3(p.x,p.y,p.z+pas);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distprecx =  sdSphere(pprecx,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distprecy =  sdSphere(pprecy,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distprecz =  sdSphere(pprecz,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distsuivx = sdSphere(psuivx,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distsuivy = sdSphere(psuivy,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distsuivz = sdSphere(psuivz,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;//On normalise les coordonnees de la normale&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 norm =  normalize(vec3(distsuivx-distprecx,distsuivy-distprecy,distsuivz-distprecz));&#xa;&#xa;    &#x9;&#x9;&#x9;&#x9;&#x9;return  vec4((dot(norm.xyz,lumiere)*distance(p.xyz,lumiere)*vec4(couleurs[j].xyz,1)).xyz,1);&#xa;&#x9;&#x9;&#x9;&#x9;}&#xa;&#x9;&#x9;&#x9;}&#xa;&#xa;&#x9;&#x9;}&#xa;&#x9;&#x9;t += pas;&#xa;&#x9;}&#xa;&#x9;&#x9;return directIllumination(pos);&#xa;&#x9;&#xa;}&#xa;&#xa;&#xa;vec4 shadowRay(){&#xa;&#xa;&#x9;//On prend la position du pixel entre [-1 ; 1]&#xa;&#x9;vec2 pos =( gl_FragCoord.xy - (512.0/2) ) / (512.0/2) ;&#xa;&#xa;&#xa;&#x9;//generer un rayon avec la camera&#xa;&#x9;float D  = 1.0/(tan(3.14/4.0)); //radian&#xa;&#x9;Ray ray = Ray( cam.e , normalize(vec3(pos.x*cam.u+pos.y*cam.v+D*cam.w)) ) ;&#xa;&#x9;Ray ray2 ;&#xa;&#x9;Plane plan ;&#xa;&#x9;Sphere ball ;&#xa;&#x9;vec3 p;&#xa;&#xa;&#x9;float t =0;&#xa;&#x9;vec4 n;&#xa;&#xa;&#x9;float pas =0.1;&#xa;&#xa;&#x9;float dist[ NUM_PLANS+NUM_SPHERES ];&#xa;&#xa;&#x9;for( int i=0;i&lt;NB_ITER_MAX;i++){&#xa;&#xa;&#x9;&#x9;p = ray.ro + ray.rd*t;&#x9;&#x9;&#xa;&#xa;&#xa;&#x9;&#x9;for(int j=0;j&lt;NUM_PLANS+NUM_SPHERES;j++){&#xa;&#x9;&#x9;&#x9;if(j &lt; NUM_PLANS){&#xa;&#x9;&#x9;&#x9;&#x9;n = vec4(murs[j].n,murs[j].d);&#xa;&#x9;&#x9;&#x9;&#x9;dist[j] = sdPlane(p,n);&#xa;&#x9;&#x9;&#x9;&#x9;if(dist[j] &lt;=0){&#xa;    &#x9;&#x9;&#x9;&#x9;&#x9;return dot(n.xyz,lumiere)*distance(p.xyz,lumiere)*vec4(couleurs[j].xyz,1);&#xa;&#xa;&#x9;&#x9;&#x9;&#x9;}&#xa;&#x9;&#x9;&#x9;}else{&#xa;&#x9;&#x9;&#x9;&#x9;dist[j] = sdSphere(p,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;if(dist[j] &lt;=0){&#xa;&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;//normales&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;//calculs des points avant et  apres selon x, y et z pour calculer le gradient -> normale&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 pprecx =  vec3(p.x-pas,p.y,p.z);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 pprecy =  vec3(p.x,p.y-pas,p.z);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 pprecz =  vec3(p.x,p.y,p.z-pas);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 psuivx =  vec3(p.x+pas,p.y,p.z);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 psuivy =  vec3(p.x,p.y+pas,p.z);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 psuivz =  vec3(p.x,p.y,p.z+pas);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distprecx =  sdSphere(pprecx,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distprecy =  sdSphere(pprecy,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distprecz =  sdSphere(pprecz,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distsuivx = sdSphere(psuivx,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distsuivy = sdSphere(psuivy,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;float distsuivz = sdSphere(psuivz,balles[j-NUM_PLANS].o,balles[j-NUM_PLANS].r);&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;//On normalise les coordonnees de la normale&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;vec3 norm =  normalize(vec3(distsuivx-distprecx,distsuivy-distprecy,distsuivz-distprecz));&#xa;&#xa;    &#x9;&#x9;&#x9;&#x9;&#x9;return vec4((dot(norm.xyz,lumiere)*distance(p.xyz,lumiere)*vec4(couleurs[j].xyz,1)).xyz,1);&#xa;&#x9;&#x9;&#x9;&#x9;}&#xa;&#x9;&#x9;&#x9;}&#xa;&#xa;&#x9;&#x9;}&#xa;&#x9;&#x9;t += pas;&#xa;&#x9;}&#xa;&#x9;&#x9;return directIllumination(pos);&#xa;&#x9;&#xa;}&#xa;&#xa;&#xa;&#xa;//Main&#xa;void main() {&#xa;&#x9;outBuffer0 = vec4(1,1,1,1);&#xa;&#x9;initCouleur();&#xa;&#x9;initCam();&#xa;&#x9;initLight();&#xa;&#x9;initPlans();&#xa;&#x9;initSpheres();&#xa;&#x9;//outBuffer0 = directIllumination(rayMarching());&#xa;&#x9;//outBuffer0 = rayMarchingSimple();&#xa;&#x9;//outBuffer0 = rayMarchingNormales();&#xa;&#x9;//outBuffer0 = rayMarchingProfondeur();&#xa;&#x9;outBuffer0 =  shadingSimple();&#xa;&#x9;//outBuffer0 =  shadowRay();&#xa;}&#xa;&#xa;" name="genericFragBody"/>
     <string val="#version 420&#xa;&#xa;layout(vertices = 4) out;&#xa;uniform vec2 mouse;&#xa;" name="genericTessCHead"/>
     <string val="void main(void) {&#xa;&#x9;gl_TessLevelOuter[0] = 1;&#xa;&#x9;gl_TessLevelOuter[1] = 1;&#xa;&#x9;gl_TessLevelOuter[2] = 1;&#xa;&#x9;gl_TessLevelOuter[3] = 1;&#xa;&#x9;gl_TessLevelInner[0] = 1;&#xa;&#x9;gl_TessLevelInner[1] = 1;&#xa;&#x9;gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;&#xa;}&#xa;" name="genericTessCBody"/>
     <string val="#version 420&#xa;&#xa;uniform vec2 mouse;&#xa;" name="genericTessEHead"/>
     <string val="layout(quads,equal_spacing) in;&#xa;&#xa;void main() {&#xa;&#x9;vec4 p1 = mix(gl_in[0].gl_Position,gl_in[1].gl_Position,gl_TessCoord.x);&#xa;&#x9;vec4 p2 = mix(gl_in[3].gl_Position,gl_in[2].gl_Position,gl_TessCoord.x);&#xa;&#x9;gl_Position = mix(p1,p2,gl_TessCoord.y);&#xa;}&#xa;" name="genericTessEBody"/>
     <string val="#version 420&#xa;&#xa;layout(triangles) in;&#xa;uniform vec2 mouse;&#xa;" name="genericGeomHead"/>
     <string val="layout(triangle_strip, max_vertices = 3) out;&#xa;&#xa;void main() {&#xa;&#x9;gl_Position = gl_in[0].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[1].gl_Position; EmitVertex();&#xa;&#x9;gl_Position = gl_in[2].gl_Position; EmitVertex();&#xa;&#x9;EndPrimitive();&#xa;}" name="genericGeomBody"/>
     <vector2f name="genericTSize">
      <float val="0" name="0"/>
      <float val="0" name="1"/>
     </vector2f>
     <vector2f name="genericTOffset">
      <float val="512" name="0"/>
      <float val="512" name="1"/>
     </vector2f>
     <bool val="1" name="genericNeedMouse"/>
     <bool val="0" name="genericNeedKeyboard"/>
     <uint val="0" name="genericNbWidgets"/>
    </IOData>
    <IOData name="nodeWidget-0">
     <uint val="1" name="nbChildren"/>
     <IOData name="childWidget-0">
      <bool val="1" name="vector2iAttribKeyframed"/>
      <vector2i name="vector2iAttribMinVal">
       <int val="-10000" name="0"/>
       <int val="-10000" name="1"/>
      </vector2i>
      <vector2i name="vector2iAttribMaxVal">
       <int val="10000" name="0"/>
       <int val="10000" name="1"/>
      </vector2i>
      <IOData name="vector2iAttribCurve">
       <vector2i name="currentVal">
        <int val="-112" name="0"/>
        <int val="430" name="1"/>
       </vector2i>
       <uint val="2" name="nbCurves"/>
       <IOData name="curve-0">
        <int val="0" name="interpType"/>
        <int val="0" name="leftType"/>
        <int val="0" name="rightType"/>
        <IOData name="interpolator">
         <uint val="1" name="nbPoints"/>
         <uint val="0" name="nbTangents"/>
         <vector2f name="controlPoint-0">
          <float val="0" name="0"/>
          <float val="-112" name="1"/>
         </vector2f>
        </IOData>
       </IOData>
       <IOData name="curve-1">
        <int val="0" name="interpType"/>
        <int val="0" name="leftType"/>
        <int val="0" name="rightType"/>
        <IOData name="interpolator">
         <uint val="1" name="nbPoints"/>
         <uint val="0" name="nbTangents"/>
         <vector2f name="controlPoint-0">
          <float val="0" name="0"/>
          <float val="430" name="1"/>
         </vector2f>
        </IOData>
       </IOData>
      </IOData>
      <uint val="0" name="nbChildren"/>
     </IOData>
    </IOData>
    <vector2f name="nodeOutputPos-0-0">
     <float val="56.32" name="0"/>
     <float val="28.16" name="1"/>
    </vector2f>
   </IOData>
   <float val="3.25918" name="scale"/>
   <vector2f name="offset">
    <float val="2433.89" name="0"/>
    <float val="-2978.26" name="1"/>
   </vector2f>
   <IOData name="animation">
    <uint val="0" name="firstFrame"/>
    <uint val="99" name="lastFrame"/>
    <uint val="0" name="currentFrame"/>
    <uint val="24" name="fps"/>
   </IOData>
  </IOData>
  <IOData name="animationWidget">
   <vector2i name="animationWidgetSize">
    <int val="1766" name="0"/>
    <int val="351" name="1"/>
   </vector2i>
   <IOData name="timelineWidget"/>
  </IOData>
  <IOData name="nodeListWidget"/>
  <IOData name="interactionWidget">
   <float val="0.954338" name="scale"/>
   <vector2f name="offset">
    <float val="245.138" name="0"/>
    <float val="248.85" name="1"/>
   </vector2f>
  </IOData>
  <IOData name="nodeInterfaceWidget"/>
 </IOData>
</Gratin>
